import{ip as v,iq as S,ir as q,is as F,it as W,iu as j,dC as k,dD as M,dE as b,cT as B,a6 as Y,a7 as Z,bL as J,ay as T,bc as H,iv as X,iw as K,ix as $,dB as C,dI as Q,dJ as N,h3 as ee,iy as w,dF as te,iz as ie,iA as ae,cX as se,W as y,cU as re}from"./chunk-JaFSy54E.js";import{C as ne,f as D,c as x,g as oe,D as z,Y as le,E as he,Z as de,k as L,y as R,e as ce}from"./chunk-D_yTKJJf.js";import{n as ue}from"./chunk-DaKMKTem.js";import{l as ge}from"./chunk-puDWJGdn.js";import{T as me}from"./chunk-By_2SmYK.js";function fe(i,e,t){const s=v(i)/S(i),a={width:t,height:t};return s>1.0001?a.height=t/s:s<.9999&&(a.width=t*s),a.width=Math.round(a.width/(v(i)/v(e))),a.height=Math.round(a.height/(S(i)/S(e))),a}function U(i,e){return q(i,[[e[0],e[1],-1],[e[2],e[1],-1],[e[2],e[3],-1],[e[0],e[3],-1]])}function pe(i,e,t){if(!F(e,t))return U(i,t);const s=[e[1]-t[1],Math.min(e[3],t[3])-Math.max(e[1],t[1]),t[3]-e[3],123456],a=[e[0]-t[0],Math.min(e[2],t[2])-Math.max(e[0],t[0]),t[2]-e[2],123456],o=t[2]-t[0],l=t[3]-t[1],r=a[0]>0&&a[2]>0?3:2,h=s[0]>0&&s[2]>0?3:2,n=(h+1)*(r+1),c=W(3*n),u=j(2*n),d=new Array(6*(h*r-1));let E=0,I=0,O=0,g=0,f=0;for(let p=0;p<4;p++){const P=s[p];if(P<=0)continue;let A=0;for(let _=0;_<4;_++){const G=a[_];G<=0||(c[I++]=t[0]+A,c[I++]=t[1]+E,c[I++]=-1,u[O++]=A/o,u[O++]=E/l,_<3&&p<3&&(_!==1||p!==1)&&(d[f++]=g,d[f++]=g+1,d[f++]=g+r+1,d[f++]=g+1,d[f++]=g+r+2,d[f++]=g+r+1),g++,A+=G)}E+=P}const V=new Array(d.length);return new k(i,[[M.POSITION,new b(c,d,3,!0)],[M.NORMAL,new b(_e,V,3,!0)],[M.UV0,new b(u,d,2,!0)]])}const _e=[0,0,1];let m=class extends B(ue(re)){constructor(){super(...arguments),this.drapeSourceType=Y.RasterImage,this.updatePolicy=Z.SYNC,this.fullExtentInLocalViewSpatialReference=null,this.maximumDataResolution=null,this._images=new Array,this._extents=new Array,this._overlays=new Array,this.updateWhenStationary=!0,this._drapeSourceRenderer=null,this.refreshDebounced=ne(async i=>{this.destroyed||await this._doRefresh(i).catch(e=>{D(e)||x.getLogger(this).error(e)})},2e3)}initialize(){this._drapeSourceRenderer=this.view.basemapTerrain.overlayManager.registerGeometryDrapeSource(this),this.addHandles(oe(()=>this.view.basemapTerrain.overlayManager.unregisterDrapeSource(this))),this.addResolvingPromise(ge(this).then(i=>this._set("fullExtentInLocalViewSpatialReference",i))),this._updatingHandles.add(()=>this.suspended,()=>this._suspendedChangeHandler()),this.addHandles(this.view.resourceController.scheduler.registerIdleStateCallbacks(()=>{this._isScaleRangeActive()&&this.notifyChange("suspended")},()=>{})),this._isScaleRangeLayer()&&this._updatingHandles.add(()=>this.layer.effectiveScaleRange,()=>this.notifyChange("suspended"))}destroy(){this.clear()}setDrapingExtent(i,e){this._spatialReference=e,i.forEach((t,s)=>{this._overlays[s]=t,this._updateImageExtent(t,s)})}_updateImageExtent(i,e){const t=this._clippedExtent(i.extent,ye);if(t==null)return;const s=fe(i.extent,t,i.resolution);let a=i.pixelRatio*this.view.state.pixelRatio;const{layer:o}=this;if("imageMaxWidth"in o&&o.imageMaxWidth!=null||"imageMaxHeight"in o&&o.imageMaxHeight!=null){const r=o.imageMaxWidth,h=o.imageMaxHeight;if(s.width>r){const n=r/s.width;s.height=Math.floor(s.height*n),s.width=r,a*=n}if(s.height>h){const n=h/s.height;s.width=Math.floor(s.width*n),s.height=h,a*=n}}const l=this._extents[e];l&&J(l.extent,t)&&this._imageSizeEquals(t,l.imageSize,s)||(this._extents[e]={extent:T(t),imageSize:s,pixelRatio:a},this.suspended||this._fetch(e).catch(r=>{D(r)||x.getLogger(this).error(r)}))}clear(){for(let i=0;i<this._images.length;i++)this._clearImage(i)}async doRefresh(){return this._doRefresh()}async _doRefresh(i){if(this.suspended)return;const e=[];for(let t=0;t<this._extents.length;t++)this._extents[t]&&e.push(this._fetch(t,i));await Promise.allSettled(e)}canResume(){if(!super.canResume())return!1;const i=this.layer;if(this._isScaleRangeActive()){const{minScale:e,maxScale:t}=i.effectiveScaleRange,s=this.view.scale;if(s<t||e>0&&s>e)return!1}return!0}async processResult(i,e,t){(e instanceof HTMLImageElement||e instanceof HTMLCanvasElement)&&(i.image=e)}findExtentInfoAt(i){for(const e of this._extents){const t=e.extent;if(new H(t[0],t[1],t[2],t[3],this._spatialReference).contains(i))return e}return null}getFetchOptions(){}async redraw(i,e){await X(this._images,async(t,s)=>{t&&(await i(t,e),await this._createStageObjects(s,t.image,e))})}_imageSizeEquals(i,e,t){if(!this.maximumDataResolution)return!1;const s=v(i)/this.maximumDataResolution.x,a=S(i)/this.maximumDataResolution.y,o=s/e.width,l=a/e.height,r=s/t.width,h=a/t.height,n=Math.abs(o-r),c=Math.abs(l-h),u=K.TESTS_DISABLE_OPTIMIZATIONS?0:1.5;return n<=u&&c<=u}async _fetch(i,e){if(this.suspended)return;const t=this._extents[i],s=t.extent;this._images[i]||(this._images[i]={texture:null,material:null,renderGeometry:null,loadingPromise:null,loadingAbortController:null,image:null,pixelData:null,renderExtent:T(s)});const a=this._images[i];a.loadingAbortController=z(a.loadingAbortController);const o=new H(s[0],s[1],s[2],s[3],this._spatialReference);if(o.width===0||o.height===0)return void this._clearImage(i);const l=new AbortController;a.loadingAbortController=l,le(e,()=>l.abort());const r=l.signal,h=this._waitFetchReady(r).then(async()=>{const n={requestAsImageElement:!0,pixelRatio:this._overlays[i].pixelRatio,...this.getFetchOptions(),signal:r},{height:c,width:u}=t.imageSize;return this.layer.fetchImage(o,u,c,n)}).then(n=>{if(he(r))throw x.getLogger(this).warnOnce("A call to fetchImage resolved even though the request was aborted. fetchImage should not resolve if options.signal.aborted is true."),de();return this.processResult(a,n)}).then(()=>{$(a.renderExtent,s)});a.loadingPromise=h,await this._updatingHandles.addPromise(h.then(async()=>{L(r),await this._createStageObjects(i,a.image,r)}).catch(n=>{throw n&&!D(n)&&x.getLogger(this).error(n),n}).finally(()=>{h===a.loadingPromise&&(a.loadingPromise=null,a.loadingAbortController=null)}))}_clearImage(i){const e=this._images[i];if(e){e.renderGeometry!=null&&(this._drapeSourceRenderer.removeGeometries([e.renderGeometry],C.UPDATE),e.renderGeometry=null);const t=this.view._stage,s=e.texture;s?.unload(),t.remove(s),e.texture=null,t.remove(e.material),e.material=null,e.loadingAbortController=z(e.loadingAbortController),e.loadingPromise=null,e.image=null,e.pixelData=null}}async _createStageObjects(i,e,t){const s=this.view._stage,a=this._images[i],o=()=>{a.texture?.unload(),s.remove(a.texture),a.texture=null,a.renderGeometry&&(this._drapeSourceRenderer.removeGeometries([a.renderGeometry],C.UPDATE),a.renderGeometry=null)};if(e){const l=new Q(e,{width:e.width,height:e.height,preMultiplyAlpha:!0,wrap:{s:N.CLAMP_TO_EDGE,t:N.CLAMP_TO_EDGE}});let r;if(await ee(this._images[i===w.INNER?w.OUTER:w.INNER].loadingPromise),L(t),o(),await s.schedule(()=>l.load(s.renderView.renderingContext),t),s.add(l),a.texture=l,a.material==null?(a.material=new me({transparent:!0,textureId:l.id}),s.add(a.material)):a.material.setParameters({textureId:l.id}),i===w.INNER)r=U(a.material,a.renderExtent);else{const h=this._images[0].renderExtent;if(!h)return void o();r=pe(a.material,h,a.renderExtent)}a.renderGeometry=new te(r),a.renderGeometry.localOrigin=this._overlays[i].renderLocalOrigin,this._drapeSourceRenderer.addGeometries([a.renderGeometry],C.UPDATE)}else o(),s.remove(a.material),a.material=null}_isScaleRangeLayer(){return"effectiveScaleRange"in this.layer}_isScaleRangeActive(){const i=this.layer;if(!this._isScaleRangeLayer())return!1;const{minScale:e,maxScale:t}=i.effectiveScaleRange;return ie(e,t)}_clippedExtent(i,e){if(this.view.viewingMode!=="local")return $(e,i);const t=this.view.basemapTerrain;return t.ready?ae(i,t.extent,e):$(e,i)}_suspendedChangeHandler(){this.suspended?this.clear():this.refreshDebounced()}async _waitFetchReady(i){await se(()=>this.view.stationary,i),L(i)}};y([R()],m.prototype,"layer",void 0),y([R()],m.prototype,"suspended",void 0),y([R({readOnly:!0})],m.prototype,"fullExtentInLocalViewSpatialReference",void 0),y([R()],m.prototype,"updating",void 0),m=y([ce("esri.views.3d.layers.DynamicLayerView3D")],m);const Ee=m,ye=T();export{Ee as N};
