import{D as W,ae as H,j as V,f as N,$ as R}from"./chunk-D_yTKJJf.js";import{qC as w,jo as U,aR as B,dJ as z,jt as J,U as F,o6 as K,bp as k,b5 as G,fa as T,qD as $,qE as j,qF as Q,qG as X,qH as v,qI as Y,o2 as Z,qJ as ee,qK as C,f7 as te,cc as se}from"./chunk-C4bXDfxA.js";import{i as ie}from"./chunk-CF12NPJ1.js";let L=class{constructor(e,s){this._width=0,this._height=0,this._free=[],this._width=e,this._height=s,this._free.push(new w(0,0,e,s))}get width(){return this._width}get height(){return this._height}allocate(e,s){if(e>this._width||s>this._height)return new w;let t=null,i=-1;for(let o=0;o<this._free.length;++o){const n=this._free[o];e<=n.width&&s<=n.height&&(t===null||n.y<=t.y&&n.x<=t.x)&&(t=n,i=o)}return t===null?new w:(this._free.splice(i,1),t.width<t.height?(t.width>e&&this._free.push(new w(t.x+e,t.y,t.width-e,s)),t.height>s&&this._free.push(new w(t.x,t.y+s,t.width,t.height-s))):(t.width>e&&this._free.push(new w(t.x+e,t.y,t.width-e,t.height)),t.height>s&&this._free.push(new w(t.x,t.y+s,e,t.height-s))),new w(t.x,t.y,e,s))}release(e){for(let s=0;s<this._free.length;++s){const t=this._free[s];if(t.y===e.y&&t.height===e.height&&t.x+t.width===e.x)t.width+=e.width;else if(t.x===e.x&&t.width===e.width&&t.y+t.height===e.y)t.height+=e.height;else if(e.y===t.y&&e.height===t.height&&e.x+e.width===t.x)t.x=e.x,t.width+=e.width;else{if(e.x!==t.x||e.width!==t.width||e.y+e.height!==t.y)continue;t.y=e.y,t.height+=e.height}this._free.splice(s,1),this.release(e)}this._free.push(e)}},q=class{constructor(e,s,t){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,this.width=e,this.height=s,this._glyphSource=t,this._binPack=new L(e-4,s-4),this._glyphData.push(new Uint8Array(e*s)),this._dirties.push(!0),this._textures.push(void 0)}getGlyphItems(e,s){const t=[],i=this._glyphSource,o=new Set,n=1/256;for(const l of s){const a=Math.floor(l*n);o.add(a)}const r=[];return o.forEach(l=>{const a=e+l;if(this._rangePromises.has(a))r.push(this._rangePromises.get(a));else{const c=i.getRange(e,l).then(()=>{this._rangePromises.delete(a)},()=>{this._rangePromises.delete(a)});this._rangePromises.set(a,c),r.push(c)}}),Promise.all(r).then(()=>{let l=this._glyphIndex[e];l||(l={},this._glyphIndex[e]=l);for(const a of s){const c=l[a];if(c){t[a]={sdf:!0,rect:c.rect,metrics:c.metrics,page:c.page,code:a};continue}const _=i.getGlyph(e,a);if(!_?.metrics)continue;const u=_.metrics;let h;if(u.width===0)h=new w(0,0,0,0);else{const y=u.width+6,d=u.height+2*3;let p=y%4?4-y%4:4,m=d%4?4-d%4:4;p===1&&(p=5),m===1&&(m=5),h=this._binPack.allocate(y+p,d+m),h.isEmpty&&(this._dirties[this._currentPage]||(this._glyphData[this._currentPage]=null),this._currentPage=this._glyphData.length,this._glyphData.push(new Uint8Array(this.width*this.height)),this._dirties.push(!0),this._textures.push(void 0),this._binPack=new L(this.width-4,this.height-4),h=this._binPack.allocate(y+p,d+m));const b=this._glyphData[this._currentPage],S=_.bitmap;let P,I;if(S)for(let x=0;x<d;x++){P=y*x,I=this.width*(h.y+x+1)+h.x;for(let D=0;D<y;D++)b[I+D+1]=S.at(P+D)}}l[a]={rect:h,metrics:u,tileIDs:null,page:this._currentPage},t[a]={sdf:!0,rect:h,metrics:u,page:this._currentPage,code:a},this._dirties[this._currentPage]=!0}return t})}removeGlyphs(e){for(const s in this._glyphIndex){const t=this._glyphIndex[s];if(!t)continue;let i;for(const o in t)if(i=t[o],i.tileIDs.delete(e),i.tileIDs.size===0){const n=this._glyphData[i.page],r=i.rect;let l,a;for(let c=0;c<r.height;c++)for(l=this.width*(r.y+c)+r.x,a=0;a<r.width;a++)n[l+a]=0;delete t[o],this._dirties[i.page]=!0}}}bind(e,s,t,i=0){if(!this._textures[t]){const n=new U;n.pixelFormat=B.ALPHA,n.wrapMode=z.CLAMP_TO_EDGE,n.width=this.width,n.height=this.height,this._textures[t]=new J(e,n,new Uint8Array(this.width*this.height))}const o=this._textures[t];o.setSamplingMode(s),this._dirties[t]&&o.setData(this._glyphData[t]),e.bindTexture(o,i),this._dirties[t]=!1}destroy(){this.dispose()}dispose(){this._glyphData.length=0,this._binPack=null;for(const e of this._textures)e&&e.dispose();this._textures.length=0}};class M{constructor(e){if(this._metrics=[],!e)return void(this._allBitmaps=null);const s=new Map;let t=0;for(;e.next();)switch(e.tag()){case 1:{const n=e.getMessage();for(;n.next();)switch(n.tag()){case 3:{const r=n.getMessage();let l,a,c,_,u,h,g;for(;r.next();)switch(r.tag()){case 1:l=r.getUInt32();break;case 2:a=r.getBytes();break;case 3:c=r.getUInt32();break;case 4:_=r.getUInt32();break;case 5:u=r.getSInt32();break;case 6:h=r.getSInt32();break;case 7:g=r.getUInt32();break;default:r.skip()}if(r.release(),l){const y=a?.length??0;this._metrics[l]={width:c,height:_,left:u,top:h,advance:g,startOffset:t,length:y},s.set(l,a),t+=y}break}default:n.skip()}n.release();break}default:e.skip()}const i=new Uint8Array(t),o=this._metrics;for(const[n,r]of s){const{startOffset:l,length:a}=o[n];if(r)for(let c=0;c<a;++c)i[l+c]=r[c]}this._allBitmaps=i}getMetrics(e){return this._metrics[e]}getBitmap(e){if(!this._allBitmaps)return;const s=this._metrics[e];if(s===void 0)return;const{startOffset:t,length:i}=s;return i!==0?new re(this._allBitmaps,t,i):void 0}}class oe{constructor(){this._ranges=[]}get ranges(){return this._ranges}getRange(e){return this._ranges[e]}addRange(e,s){this._ranges[e]=s}}let A=class{constructor(e){this._glyphInfo={},this._baseURL=e}getRange(e,s){const t=this._getFontStack(e);if(t.getRange(s))return Promise.resolve();const i=256*s,o=i+255;if(this._baseURL){const n=this._baseURL.replace("{fontstack}",e).replace("{range}",i+"-"+o);return F(n,{responseType:"array-buffer"}).then(r=>{t.addRange(s,new M(new K(new Uint8Array(r.data),new DataView(r.data))))}).catch(()=>{t.addRange(s,new M)})}return t.addRange(s,new M),Promise.resolve()}getGlyph(e,s){const t=this._getFontStack(e);if(!t)return;const i=Math.floor(s/256),o=t.getRange(i);return o?{metrics:o.getMetrics(s),bitmap:o.getBitmap(s)}:void 0}_getFontStack(e){let s=this._glyphInfo[e];return s||(s=this._glyphInfo[e]=new oe),s}},re=class{constructor(e,s,t){this._array=e,this._start=s,this.length=t}at(e){return 0<=e&&e<this.length?this._array[this._start+e]:void 0}};const ne="dasharray-";let O=class E{constructor(e,s,t=0){this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,(e<=0||s<=0)&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=e,this._pageHeight=s,t>0&&(this._maxItemSize=t),this._binPack=new L(e-4,s-4)}destroy(){this.dispose()}dispose(){this._binPack=null,this._mosaicsData.length=0,this._mosaicRects={};for(const e of this._textures)e&&e.dispose();this._textures.length=0}getWidth(e){return e>=this._size.length?-1:this._size[e][0]}getHeight(e){return e>=this._size.length?-1:this._size[e][1]}getPageSize(e){return e>=this._size.length?null:this._size[e]}setSpriteSource(e){if(this.dispose(),this.pixelRatio=e.devicePixelRatio,this._mosaicsData.length===0){this._binPack=new L(this._pageWidth-4,this._pageHeight-4);const s=Math.floor(this._pageWidth),t=Math.floor(this._pageHeight),i=new Uint32Array(s*t);this._mosaicsData[0]=i,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=e}getSpriteItem(e,s=!1){let t,i,o=this._mosaicRects[e];if(o)return o;if(!this._sprites||this._sprites.loadStatus!=="loaded"||(e&&e.startsWith(ne)?([t,i]=this._rasterizeDash(e),s=!0):t=this._sprites.getSpriteInfo(e),!t?.width||!t.height||t.width<0||t.height<0))return null;const n=t.width,r=t.height,[l,a,c]=this._allocateImage(n,r);return l.width<=0?null:(this._copy(l,t,a,c,s,i),o={type:"sprite",rect:l,width:n,height:r,sdf:t.sdf,simplePattern:!1,rasterizationScale:t.pixelRatio,page:a},this._mosaicRects[e]=o,o)}getSpriteItems(e){const s={};for(const t of e)s[t.name]=this.getSpriteItem(t.name,t.repeat);return s}getMosaicItemPosition(e,s){const t=this.getSpriteItem(e,s),i=t&&t.rect;if(!i)return null;i.width=t.width,i.height=t.height;const o=t.width,n=t.height,r=2;return{tl:[i.x+r,i.y+r],br:[i.x+r+o,i.y+r+n],page:t.page}}bind(e,s,t=0,i=0){if(t>=this._size.length||t>=this._mosaicsData.length)return;if(!this._textures[t]){const n=new U;n.wrapMode=z.CLAMP_TO_EDGE,n.width=this._size[t][0],n.height=this._size[t][1],this._textures[t]=new J(e,n,new Uint8Array(this._mosaicsData[t].buffer))}const o=this._textures[t];o.setSamplingMode(s),this._dirties[t]&&o.setData(new Uint8Array(this._mosaicsData[t].buffer)),e.bindTexture(o,i),this._dirties[t]=!1}static _copyBits(e,s,t,i,o,n,r,l,a,c,_){let u=i*s+t,h=l*n+r;if(_){h-=n;for(let g=-1;g<=c;g++,u=((g+c)%c+i)*s+t,h+=n)for(let y=-1;y<=a;y++)o[h+y]=e[u+(y+a)%a]}else for(let g=0;g<c;g++){for(let y=0;y<a;y++)o[h+y]=e[u+y];u+=s,h+=n}}_copy(e,s,t,i,o,n){if(!this._sprites||this._sprites.loadStatus!=="loaded"||t>=this._mosaicsData.length)return;const r=new Uint32Array(n?n.buffer:this._sprites.image.buffer),l=this._mosaicsData[t];l&&r||console.error("Source or target images are uninitialized!");const a=2,c=n?s.width:this._sprites.width;E._copyBits(r,c,s.x,s.y,l,i[0],e.x+a,e.y+a,s.width,s.height,o),this._dirties[t]=!0}_allocateImage(e,s){e+=2,s+=2;const t=Math.max(e,s);if(this._maxItemSize&&this._maxItemSize<t){const r=new w(0,0,e,s);return this._mosaicsData.push(new Uint32Array(e*s)),this._dirties.push(!0),this._size.push([e,s]),this._textures.push(void 0),[r,this._mosaicsData.length-1,[e,s]]}let i=e%4?4-e%4:4,o=s%4?4-s%4:4;i===1&&(i=5),o===1&&(o=5);const n=this._binPack.allocate(e+i,s+o);return n.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new L(this._pageWidth-4,this._pageHeight-4),this._allocateImage(e,s)):[n,this._currentPage,[this._pageWidth,this._pageHeight]]}_rasterizeDash(e){const s=/\[(.*?)\]/,t=e.match(s);if(!t)return null;const i=t[1].split(",").map(Number),o=e.slice(e.lastIndexOf("-")+1),[n,r,l]=ie(i,o);return[{x:0,y:0,width:r,height:l,sdf:!0,pixelRatio:1},new Uint8Array(n.buffer)]}};class Se{constructor(e,s,t,i){this._layer=e,this._styleRepository=s,this.devicePixelRatio=t,this._sourceDataMaxLOD=i,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null,this._spriteSourceAbortController=null,this._startOptionsInputSignal=null,this._inputSignalEventListener=null}destroy(){this._connection?.close(),this._connection=null,this._styleRepository=null,this._layer=null,this._spriteMosaic?.destroy(),this._spriteMosaic=null,this._glyphMosaic=null,this._spriteSourceAbortController=W(this._spriteSourceAbortController),this._spriteSourcePromise=null,this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,this._inputSignalEventListener=null}get spriteMosaic(){return this._spriteSourcePromise.then(()=>this._spriteMosaic)}get glyphMosaic(){return this._glyphMosaic}async start(e){this._requestSprite(e);const s=this._layer.currentStyleInfo.glyphsUrl,t=new A(s?k(s,{...this._layer.customParameters,token:this._layer.apiKey}):null);this._glyphMosaic=new q(1024,1024,t),this._broadcastPromise=G("WorkerTileHandler",{client:this,schedule:e.schedule,signal:e.signal}).then(i=>{if(this._layer&&(this._connection?.close(),this._connection=i,this._layer&&!this._connection.closed)){const o=i.broadcast("setStyle",{style:this._layer.currentStyleInfo.style,sourceDataMaxLOD:this._sourceDataMaxLOD},e);Promise.all(o).catch(n=>H(n))}})}_requestSprite(e){this._spriteSourceAbortController?.abort();const s=new AbortController;this._spriteSourceAbortController=s;const t=e?.signal;this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,t&&(this._inputSignalEventListener=le(s),t.addEventListener("abort",this._inputSignalEventListener,{once:!0}));const{signal:i}=s,o={...e,signal:i};this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,o),this._spriteSourcePromise.then(n=>{V(i),this._spriteMosaic=new O(1024,1024,250),this._spriteMosaic.setSpriteSource(n)})}async updateStyle(e){return await this._broadcastPromise,this._broadcastPromise=Promise.all(this._connection.broadcast("updateStyle",e)),this._broadcastPromise}setSpriteSource(e){const s=new O(1024,1024,250);return s.setSpriteSource(e),this._spriteMosaic=s,this._spriteSourcePromise=Promise.resolve(e),this._spriteSourceAbortController=null,s}async setStyle(e,s,t){await this._broadcastPromise,this._styleRepository=e,this._sourceDataMaxLOD=t,this._requestSprite();const i=new A(this._layer.currentStyleInfo.glyphsUrl?k(this._layer.currentStyleInfo.glyphsUrl,{...this._layer.customParameters,token:this._layer.apiKey}):null);return this._glyphMosaic=new q(1024,1024,i),this._broadcastPromise=Promise.all(this._connection.broadcast("setStyle",{style:s,sourceDataMaxLOD:this._sourceDataMaxLOD})),this._broadcastPromise}async fetchTileData(e,s){const t=await this._getRefKeys(e,s);return this._getSourcesData(Object.keys(this._layer.sourceNameToSource),t,s)}async fetchTilePBFs(e){const s=Object.keys(this._layer.sourceNameToSource),t={},i=await this._getRefKeys(e,t),o=[],n=[];for(let r=0;r<i.length;r++)if(i[r].value==null||s[r]==null)n.push(null);else{const l=i[r].value,a=this._getTilePayload(l,s[r],t);a.then(c=>{o.push({...c,key:l})}),n.push(a)}return Promise.all(n).then(()=>o)}async parseTileData(e,s){const t=e&&e.data;if(!t)return null;const{sourceName2DataAndRefKey:i,transferList:o}=t;return Object.keys(i).length===0?null:this._broadcastPromise.then(()=>this._connection.invoke("createTileAndParse",{key:e.key.id,sourceName2DataAndRefKey:i,styleLayerUIDs:e.styleLayerUIDs},{...s,transferList:o}))}async getSprites(e){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(e)}getGlyphs(e){return this._glyphMosaic.getGlyphItems(e.font,e.codePoints)}async _getTilePayload(e,s,t){const i=T.pool.acquire(e.id),o=this._layer.sourceNameToSource[s],{level:n,row:r,col:l}=i;T.pool.release(i);try{return{protobuff:await o.requestTile(n,r,l,t),sourceName:s}}catch(a){if(N(a))throw a;return{protobuff:null,sourceName:s}}}async _getRefKeys(e,s){const t=this._layer.sourceNameToSource,i=new Array;for(const o in t){const n=t[o].getRefKey(e,s);i.push(n)}return R(i)}_getSourcesData(e,s,t){const i=[];for(let o=0;o<s.length;o++)if(s[o].value==null||e[o]==null)i.push(null);else{const n=s[o].value,r=this._getTilePayload(n,e[o],t);i.push(r)}return R(i).then(o=>{const n={},r=[];for(let l=0;l<o.length;l++){const a=o[l].value;if(a&&a.protobuff&&a.protobuff.byteLength>0){const c=s[l].value.id;n[a.sourceName]={refKey:c,protobuff:a.protobuff},r.push(a.protobuff)}}return{sourceName2DataAndRefKey:n,transferList:r}})}}function le(f){return()=>f.abort()}function ae(f,e,s,t,i,o){const{iconRotationAlignment:n,textRotationAlignment:r,iconTranslate:l,iconTranslateAnchor:a,textTranslate:c,textTranslateAnchor:_}=t;let u=0;for(const h of f.colliders){const[g,y]=h.partIndex===0?l:c,d=h.partIndex===0?a:_,p=h.minLod<=o&&o<=h.maxLod;u+=p?0:1,h.enabled=p,h.xScreen=h.xTile*i[0]+h.yTile*i[3]+i[6],h.yScreen=h.xTile*i[1]+h.yTile*i[4]+i[7],d===Y.MAP?(h.xScreen+=s*g-e*y,h.yScreen+=e*g+s*y):(h.xScreen+=g,h.yScreen+=y),v.VIEWPORT===(h.partIndex===0?n:r)?(h.dxScreen=h.dxPixels,h.dyScreen=h.dyPixels):(h.dxScreen=s*(h.dxPixels+h.width/2)-e*(h.dyPixels+h.height/2)-h.width/2,h.dyScreen=e*(h.dxPixels+h.width/2)+s*(h.dyPixels+h.height/2)-h.height/2)}f.colliders.length>0&&u===f.colliders.length&&(f.unique.show=!1)}class xe{constructor(e,s,t,i,o,n){this._symbols=e,this._styleRepository=i,this._zoom=o,this._currentLayerCursor=0,this._currentSymbolCursor=0,this._styleProps=new Map,this._allNeededMatrices=new Map,this._gridIndex=new $(s,t,j),this._si=Math.sin(Math.PI*n/180),this._co=Math.cos(Math.PI*n/180);for(const r of e)for(const l of r.symbols)this._allNeededMatrices.has(l.tile)||this._allNeededMatrices.set(l.tile,Q(l.tile.transforms.tileUnitsToPixels))}work(e){const s=this._gridIndex;function t(o){const n=o.xScreen+o.dxScreen,r=o.yScreen+o.dyScreen,l=n+o.width,a=r+o.height,[c,_,u,h]=s.getCellSpan(n,r,l,a);for(let g=_;g<=h;g++)for(let y=c;y<=u;y++){const d=s.cells[g][y];for(const p of d){const m=p.xScreen+p.dxScreen,b=p.yScreen+p.dyScreen,S=m+p.width,P=b+p.height;if(!(l<m||n>S||a<b||r>P))return!0}}return!1}const i=performance.now();for(;this._currentLayerCursor<this._symbols.length;this._currentLayerCursor++,this._currentSymbolCursor=0){const o=this._symbols[this._currentLayerCursor],n=this._getProperties(o.styleLayerUID);for(;this._currentSymbolCursor<o.symbols.length;this._currentSymbolCursor++){if(this._currentSymbolCursor%100==99&&performance.now()-i>e)return!1;const r=o.symbols[this._currentSymbolCursor];if(!r.unique.show)continue;ae(r,this._si,this._co,n,this._allNeededMatrices.get(r.tile),this._zoom);const l=r.unique;if(!l.show)continue;const{iconAllowOverlap:a,iconIgnorePlacement:c,textAllowOverlap:_,textIgnorePlacement:u}=n;for(const h of r.colliders){if(!h.enabled)continue;const g=l.parts[h.partIndex];g.show&&!(h.partIndex?_:a)&&t(h)&&(h.hard?l.show=!1:g.show=!1)}if(l.show)for(const h of r.colliders){if(!h.enabled||(h.partIndex?u:c)||!l.parts[h.partIndex].show)continue;const g=h.xScreen+h.dxScreen,y=h.yScreen+h.dyScreen,d=g+h.width,p=y+h.height,[m,b,S,P]=this._gridIndex.getCellSpan(g,y,d,p);for(let I=b;I<=P;I++)for(let x=m;x<=S;x++)this._gridIndex.cells[I][x].push(h)}}}return!0}_getProperties(e){const s=this._styleProps.get(e);if(s)return s;const t=this._zoom,i=this._styleRepository.getStyleLayerByUID(e),o=i.getLayoutValue("symbol-placement",t)!==X.POINT;let n=i.getLayoutValue("icon-rotation-alignment",t);n===v.AUTO&&(n=o?v.MAP:v.VIEWPORT);let r=i.getLayoutValue("text-rotation-alignment",t);r===v.AUTO&&(r=o?v.MAP:v.VIEWPORT);const l=i.getPaintValue("icon-translate",t),a=i.getPaintValue("icon-translate-anchor",t),c=i.getPaintValue("text-translate",t),_=i.getPaintValue("text-translate-anchor",t),u={iconAllowOverlap:i.getLayoutValue("icon-allow-overlap",t),iconIgnorePlacement:i.getLayoutValue("icon-ignore-placement",t),textAllowOverlap:i.getLayoutValue("text-allow-overlap",t),textIgnorePlacement:i.getLayoutValue("text-ignore-placement",t),iconRotationAlignment:n,textRotationAlignment:r,iconTranslateAnchor:a,iconTranslate:l,textTranslateAnchor:_,textTranslate:c};return this._styleProps.set(e,u),u}}function he(f,e){if(f.priority-e.priority)return f.priority-e.priority;const s=f.tile.key,t=e.tile.key;return s.world-t.world?s.world-t.world:s.level-t.level?s.level-t.level:s.row-t.row?s.row-t.row:s.col-t.col?s.col-t.col:f.xTile-e.xTile?f.xTile-e.xTile:f.yTile-e.yTile}class ve{get running(){return this._running}constructor(e,s,t,i,o,n){this._visibleTiles=e,this._symbolRepository=s,this._createCollisionJob=t,this._assignTileSymbolsOpacity=i,this._symbolLayerSorter=o,this._isLayerVisible=n,this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}setScreenSize(e,s){this._screenWidth===e&&this._screenHeight===s||this.restart(),this._screenWidth=e,this._screenHeight=s}restart(){this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}continue(e){if(this._selectionJob||(this._selectionJob=this._createSelectionJob()),!this._selectionJobCompleted){const s=performance.now();if(!this._selectionJob.work(e)||(this._selectionJobCompleted=!0,(e=Math.max(0,e-(performance.now()-s)))===0))return!1}if(this._collisionJob||(this._collisionJob=this._createCollisionJob(this._selectionJob.sortedSymbols,this._screenWidth,this._screenHeight)),!this._collisionJobCompleted){const s=performance.now();if(!this._collisionJob.work(e)||(this._collisionJobCompleted=!0,(e=Math.max(0,e-(performance.now()-s)))===0))return!1}if(this._opacityJob||(this._opacityJob=this._createOpacityJob()),!this._opacityJobCompleted){const s=performance.now();if(!this._opacityJob.work(e)||(this._opacityJobCompleted=!0,(e=Math.max(0,e-(performance.now()-s)))===0))return!1}return this._running=!1,!0}_createSelectionJob(){const e=this._symbolRepository.uniqueSymbols;for(let l=0;l<e.length;l++){const a=e[l];for(let c=0;c<a.uniqueSymbols.length;c++){const _=a.uniqueSymbols[c];for(const u of _.tileSymbols)u.selectedForRendering=!1}}const s=[];let t=0,i=0;const o=this._isLayerVisible;function n(l){let a;const c=performance.now();for(;i<e.length;i++,t=0){const _=e[i],u=_.styleLayerUID;if(!o(u)){s[i]||(s[i]={styleLayerUID:u,symbols:[]});continue}s[i]=s[i]||{styleLayerUID:u,symbols:[]};const h=s[i];for(;t<_.uniqueSymbols.length;t++){if(a=_.uniqueSymbols[t],t%100==99&&performance.now()-c>l)return!1;let g=null,y=!1,d=!1;for(const p of a.tileSymbols)if(!d||!y){const m=p.tile;(!g||m.isCoverage||m.neededForCoverage&&!y)&&(g=p,(m.neededForCoverage||m.isCoverage)&&(d=!0),m.isCoverage&&(y=!0))}if(g.selectedForRendering=!0,d){h.symbols.push(g),a.show=!0;for(const p of a.parts)p.show=!0}else a.show=!1}}for(const _ of s)_.symbols.sort(he);return!0}const r=this._symbolLayerSorter;return{work:n,get sortedSymbols(){return s.sort(r)}}}_createOpacityJob(){const e=this._assignTileSymbolsOpacity,s=this._visibleTiles;let t=0;function i(o,n){const r=o.symbols;for(const[l,a]of r)ce(a,n);e(o,n);for(const l of o.childrenTiles)i(l,n)}return{work(o){const n=performance.now();for(;t<s.length;t++){if(performance.now()-n>o)return!1;const r=s[t];r.parentTile==null&&i(r,performance.now())}return!0}}}}function ce(f,e){for(const s of f){const t=s.unique;for(const i of t.parts){const o=i.targetOpacity>.5?1:-1;i.startOpacity+=o*((e-i.startTime)/Z),i.startOpacity=Math.min(Math.max(i.startOpacity,0),1),i.startTime=e,i.targetOpacity=t.show&&i.show?1:0}}}const ue=32,_e=8,ye=64;class Pe{constructor(e,s,t){this.tileCoordRange=e,this._visibleTiles=s,this._createUnique=t,this._tiles=new Map,this._uniqueSymbolsReferences=new Map}get uniqueSymbols(){return this._uniqueSymbolLayerArray==null&&(this._uniqueSymbolLayerArray=this._createUniqueSymbolLayerArray()),this._uniqueSymbolLayerArray}get uniqueSymbolsReferences(){return this._uniqueSymbolsReferences}add(e,s){this._uniqueSymbolLayerArray=null;let t=this._tiles.get(e.id);t||(t={symbols:new Map},this._tiles.set(e.id,t));const i=new Map;if(s)for(const r of s)t.symbols.has(r)&&(i.set(r,t.symbols.get(r)),t.symbols.delete(r));else for(const[r,l]of e.layerData)t.symbols.has(r)&&(i.set(r,t.symbols.get(r)),t.symbols.delete(r));this._removeSymbols(i);const o=e.symbols,n=new Map;for(const[r,l]of o){let a=l.length;if(a>=ue){let c=this.tileCoordRange;do c/=2,a/=4;while(a>_e&&c>ye);const _=new $(this.tileCoordRange,this.tileCoordRange,c);n.set(r,{flat:l,index:_}),t.symbols.set(r,{flat:l,index:_});for(const u of l)_.getCell(u.xTile,u.yTile).push(u)}else n.set(r,{flat:l}),t.symbols.set(r,{flat:l})}this._addSymbols(e.key,o)}deleteStyleLayers(e){this._uniqueSymbolLayerArray=null;for(const[s,t]of this._tiles){const i=new Map;for(const o of e)t.symbols.has(o)&&(i.set(o,t.symbols.get(o)),t.symbols.delete(o));this._removeSymbols(i),t.symbols.size===0&&this._tiles.delete(s)}}removeTile(e){this._uniqueSymbolLayerArray=null;const s=this._tiles.get(e.id);if(!s)return;const t=new Map;for(const[i,o]of e.symbols)s.symbols.has(i)&&(t.set(i,s.symbols.get(i)),s.symbols.delete(i));this._removeSymbols(t),s.symbols.size===0&&this._tiles.delete(e.id)}querySymbols(e,s,t,i){const o=[],n=this.uniqueSymbols;for(const r of n){const l=r.styleLayerUID,a=r.uniqueSymbols;for(const c of a){const _=c.tileSymbols.find(u=>u.selectedForRendering);_&&ee(_,e,s*(window.devicePixelRatio||1),t)&&o.push({vtlSymbol:_,styleLayerUID:l,tileKey:_.tile.key})}}return o}_removeSymbols(e){for(const[s,{flat:t}]of e)for(const i of t){const o=i.unique,n=o.tileSymbols,r=n.length-1;for(let l=0;l<r;l++)if(n[l]===i){n[l]=n[r];break}if(n.length=r,r===0){const l=this._uniqueSymbolsReferences.get(s);l.delete(o),l.size===0&&this._uniqueSymbolsReferences.delete(s)}i.unique=null}}_addSymbols(e,s){if(s.size===0)return;const t=this._visibleTiles;for(const i of t)i.parentTile||i.key.world!==e.world||i.key.level===e.level&&!i.key.equals(e)||this._matchSymbols(i,e,s);for(const[i,o]of s)for(const n of o)if(n.unique==null){const r=this._createUnique();n.unique=r,r.tileSymbols.push(n);let l=this._uniqueSymbolsReferences.get(i);l||(l=new Set,this._uniqueSymbolsReferences.set(i,l)),l.add(r)}}_matchSymbols(e,s,t){if(e.key.level>s.level){const o=e.key.level-s.level;if(e.key.row>>o!==s.row||e.key.col>>o!==s.col)return}if(s.level>e.key.level){const o=s.level-e.key.level;if(s.row>>o!==e.key.row||s.col>>o!==e.key.col)return}if(s.equals(e.key)){for(const o of e.childrenTiles)this._matchSymbols(o,s,t);return}const i=new Map;for(const[o,n]of t){const r=[];for(const _ of n){const u=C(this.tileCoordRange,_.xTile,s.level,s.col,e.key.level,e.key.col),h=C(this.tileCoordRange,_.yTile,s.level,s.row,e.key.level,e.key.row);u>=0&&u<this.tileCoordRange&&h>=0&&h<this.tileCoordRange&&r.push({symbol:_,xTransformed:u,yTransformed:h})}const l=[],a=e.key.level<s.level?1:1<<e.key.level-s.level,c=this._tiles.get(e.id).symbols.get(o);if(c){const _=c.flat;for(const u of r){let h,g=!1;const y=u.xTransformed,d=u.yTransformed;h=c.index!=null?c.index.getCell(y,d):_;const p=u.symbol,m=p.hash;for(const b of h)if(m===b.hash&&Math.abs(y-b.xTile)<=a&&Math.abs(d-b.yTile)<=a){const S=b.unique;p.unique=S,S.tileSymbols.push(p),g=!0;break}g||l.push(p)}}l.length>0&&i.set(o,l)}for(const o of e.childrenTiles)this._matchSymbols(o,s,i)}_createUniqueSymbolLayerArray(){const e=this._uniqueSymbolsReferences,s=new Array(e.size);let t,i=0;for(const[o,n]of e){const r=new Array(n.size);t=0;for(const l of n)r[t++]=l;s[i]={styleLayerUID:o,uniqueSymbols:r},i++}return s}}class Ie extends te{constructor(){super(...arguments),this._fullCacheLodInfos=null,this._levelByScale={}}getTileParentId(e){const s=T.pool.acquire(e),t=s.level===0?null:T.getId(s.level-1,s.row>>1,s.col>>1,s.world);return T.pool.release(s),t}getTileCoverage(e,s,t=!0,i){const o=super.getTileCoverage(e,s,t,i);if(!o)return o;const n=1<<o.lodInfo.level;return o.spans=o.spans.filter(r=>r.row>=0&&r.row<n),o}scaleToLevel(e){if(this._fullCacheLodInfos||this._initializeFullCacheLODs(this._lodInfos),this._levelByScale[e])return this._levelByScale[e];{const s=this._fullCacheLodInfos;if(e>s[0].scale)return s[0].level;let t,i;for(let o=0;o<s.length-1;o++)if(i=s[o+1],e>i.scale)return t=s[o],t.level+(t.scale-e)/(t.scale-i.scale);return s[s.length-1].level}}_initializeFullCacheLODs(e){let s;if(e[0].level===0)s=e.map(t=>({level:t.level,resolution:t.resolution,scale:t.scale}));else{const t=this.tileInfo.size[0],i=this.tileInfo.spatialReference;s=se.create({size:t,spatialReference:i}).lods.map(o=>({level:o.level,resolution:o.resolution,scale:o.scale}))}for(let t=0;t<s.length;t++)this._levelByScale[s[t].scale]=s[t].level;this._fullCacheLodInfos=s}}export{ve as e,Se as h,xe as l,Pe as n,Ie as t};
